{% extends "base.html" %}

{% block head %}
<title>{{ title }}</title>
<!-- Add Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
{% endblock %}

{% block additional_styles %}
{% include "_project_styles.html" %}
<!-- Add Chart.js library -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
{% endblock %}

{% block content %}
<div class="container">
    <!-- Project Header -->
    {% include "_project_header.html" %}

    <div class="row project-row">
        <!-- Project Sidebar -->
        <div class="col-md-3 mb-4">
            {% include "_project_sidebar.html" %}
        </div>
        
        <!-- Project Content -->
        <div class="col-md-9">
            <div class="card project-content-card">
    <div class="card-body">
        <div class="tab-content">
            <!-- Overview Tab -->
                        {% include "_project_overview.html" %}

            <!-- Chat Tab -->
                        {% include "_project_chat.html" %}
                        
                        <!-- Tasks Tab -->
                        {% include "_project_tasks.html" %}

            <!-- Files Tab -->
                        {% include "_project_files.html" %}
                        
                        <!-- Graphs Tab -->
                        {% include "_project_graphs.html" %}
                        
                        <!-- Members Tab -->
                        {% include "_project_members.html" %}
                        </div>
                                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
    // Cache duration and keys
    const CACHE_DURATION_MS = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
    const OVERVIEW_CACHE_KEY = `project_overview_{{ project._id }}`;
    const GRAPHS_CACHE_KEY = `project_graphs_{{ project._id }}`;
    
    // Global map to store active Chart instances
    let activeCharts = {};

    // Define a professional color palette
    const professionalPalette = [
        '#3B82F6', // Blue-500
        '#10B981', // Green-500
        '#EF4444', // Red-500
        '#F59E0B', // Amber-500 (Orange)
        '#8B5CF6', // Violet-500 (Purple)
        '#EC4899', // Pink-500
        '#6B7280', // Gray-500
        '#374151', // Gray-700
        '#F97316', // Orange-500
        '#14B8A6', // Teal-500
    ];

    // Enhanced default chart options
    const chartOptions = {
        responsive: true,
        maintainAspectRatio: false, // Allows height control via CSS
        plugins: {
            legend: {
                position: 'top',
                labels: {
                    padding: 15,
                    font: {
                        size: 13
                    },
                    color: '#495057' // Use a standard text color
                }
            },
            tooltip: {
                enabled: true,
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                titleFont: {
                    size: 14,
                    weight: 'bold',
                },
                bodyFont: {
                    size: 12,
                },
                padding: 10,
                cornerRadius: 4,
                displayColors: true, // Show color boxes in tooltips
                boxPadding: 3,
            }
        },
        scales: {
            x: {
                grid: {
                    display: false // Hide vertical grid lines
                },
                ticks: {
                    color: '#6c757d',
                    font: {
                        size: 12
                    },
                    maxRotation: 0, // Prevent label rotation
                    autoSkip: true, // Allow skipping labels if too dense
                    maxTicksLimit: 10 // Limit number of ticks
                }
            },
            y: {
                grid: {
                    color: '#e9ecef', // Lighter horizontal grid lines
                    drawBorder: false,
                },
                ticks: {
                    color: '#6c757d',
                    font: {
                        size: 12
                    },
                    padding: 10,
                },
                beginAtZero: true // Generally good practice
            }
        },
        animation: {
            duration: 800, // Smooth animation
            easing: 'easeInOutQuart'
        },
        elements: {
            line: {
                tension: 0.3 // Slightly curved lines
            },
            bar: {
                borderRadius: 4, // Slightly rounded bars
                borderSkipped: 'bottom'
            }
        }
    };
    
    // Status dropdown change handler
    const statusDropdown = document.getElementById('status-dropdown');
    if (statusDropdown) {
        statusDropdown.addEventListener('change', function() {
            const newStatus = this.value;
            
            // Make API call to update project status
            fetch(`/api/projects/{{ project._id }}/update-status`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ status: newStatus })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status) {
                    console.log('Project status updated successfully');
                } else if (data.error) {
                    console.error('Error updating project status:', data.error);
                    // Reset dropdown to previous value
                    statusDropdown.value = '{{ project.status }}';
                }
            })
            .catch(error => {
                console.error('Error updating project status:', error);
                // Reset dropdown to previous value
                statusDropdown.value = '{{ project.status }}';
            });
        });
    }
    
    // Task filtering functionality
    const taskFilterStatus = document.getElementById('task-filter-status');
    const taskFilterAssignee = document.getElementById('task-filter-assignee');
    const taskFilterPriority = document.getElementById('task-filter-priority');
    const taskItems = document.querySelectorAll('.task-item');
    
    function filterTasks() {
        const statusFilter = taskFilterStatus ? taskFilterStatus.value : 'all';
        const assigneeFilter = taskFilterAssignee ? taskFilterAssignee.value : 'all';
        const priorityFilter = taskFilterPriority ? taskFilterPriority.value : 'all';
        
        taskItems.forEach(item => {
            const matchesStatus = statusFilter === 'all' || item.dataset.status === statusFilter;
            const matchesAssignee = assigneeFilter === 'all' || item.dataset.assignee === assigneeFilter;
            const matchesPriority = priorityFilter === 'all' || item.dataset.priority === priorityFilter;
            
            if (matchesStatus && matchesAssignee && matchesPriority) {
                item.style.display = '';
            } else {
                item.style.display = 'none';
            }
        });
    }
    
    if (taskFilterStatus) taskFilterStatus.addEventListener('change', filterTasks);
    if (taskFilterAssignee) taskFilterAssignee.addEventListener('change', filterTasks);
    if (taskFilterPriority) taskFilterPriority.addEventListener('change', filterTasks);
    
    // File upload functionality
    const fileDropArea = document.getElementById('file-drop-area');
    const fileInput = document.getElementById('file-upload-input');
    const fileUploadBtn = document.getElementById('file-upload-btn');
    const projectFilesContainer = document.getElementById('project-files');
    
    if (fileDropArea && fileInput && fileUploadBtn) {
        // Handle file selection via button
        fileUploadBtn.addEventListener('click', () => {
            fileInput.click();
        });
        
        // Handle file selection
        fileInput.addEventListener('change', handleFileSelect);
        
        // Handle drag and drop events
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            fileDropArea.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        ['dragenter', 'dragover'].forEach(eventName => {
            fileDropArea.addEventListener(eventName, highlight, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            fileDropArea.addEventListener(eventName, unhighlight, false);
        });
        
        function highlight() {
            fileDropArea.classList.add('dragover');
        }
        
        function unhighlight() {
            fileDropArea.classList.remove('dragover');
        }
        
        fileDropArea.addEventListener('drop', handleDrop, false);
        
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length > 0) {
                uploadFile(files[0]);
            }
        }
        
        function handleFileSelect(e) {
            if (fileInput.files.length > 0) {
                uploadFile(fileInput.files[0]);
            }
        }
        
        function uploadFile(file) {
                const formData = new FormData();
                formData.append('file', file);
                
            // Show loading indicator
            document.getElementById('file-loading').classList.remove('d-none');
            
            fetch(`/projects/{{ project._id }}/upload`, {
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.detail || 'Error uploading file');
                    });
                }
                return response.json();
            })
            .then(data => {
                console.log('File uploaded successfully:', data);
                // Refresh file list or add the new file to the list
                window.location.reload(); // Simple refresh for now
            })
            .catch(error => {
                console.error('Error uploading file:', error);
                alert('Error uploading file: ' + error.message);
            })
            .finally(() => {
                // Hide loading indicator
                document.getElementById('file-loading').classList.add('d-none');
                // Reset file input
                fileInput.value = '';
            });
        }
        
        // File deletion
        document.querySelectorAll('.file-delete-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const fileId = this.dataset.fileId;
                if (confirm('האם אתה בטוח שברצונך למחוק קובץ זה?')) {
                    // Show loading indicator
                    document.getElementById('file-loading').classList.remove('d-none');
                    
                    fetch(`/projects/{{ project._id }}/files/${fileId}`, {
                    method: 'DELETE'
                })
                .then(response => {
                    if (!response.ok) {
                        return response.json().then(data => {
                                throw new Error(data.detail || 'Error deleting file');
                        });
                    }
                    return response.json();
                })
                .then(data => {
                        console.log('File deleted successfully:', data);
                        // Remove the file from the list
                        const fileItem = document.querySelector(`.file-item[data-file-id="${fileId}"]`);
                        if (fileItem) {
                            fileItem.remove();
                        }
                        
                        // If no files left, show empty message
                        if (projectFilesContainer.querySelectorAll('.file-item').length === 0) {
                            projectFilesContainer.innerHTML = '<li class="text-center py-4 text-muted">אין קבצים בפרויקט זה</li>';
                    }
                })
                .catch(error => {
                        console.error('Error deleting file:', error);
                        alert('Error deleting file: ' + error.message);
                    })
                    .finally(() => {
                        // Hide loading indicator
                        document.getElementById('file-loading').classList.add('d-none');
                    });
                }
            });
        });
    }
    
    // WebSocket for chat functionality
    let ws;
    const tabLinks = document.querySelectorAll('[data-bs-toggle="tab"]');
    
    tabLinks.forEach(tabLink => {
        tabLink.addEventListener('shown.bs.tab', function(event) {
            const targetTabHref = event.target.getAttribute('href');
            console.log(`Tab shown event fired for: ${targetTabHref}`); // Log which tab was shown
            
            // Update URL hash without scrolling
            const hash = targetTabHref.split('#')[1];
            history.replaceState(null, null, `#${hash}`);
            
            if (targetTabHref === '#chat') {
                // Setup WebSocket when switching to chat tab
                console.log("Setting up chat WebSocket...");
                setupChatWebSocket();
                fetchChatHistory();
            } else if (targetTabHref === '#overview') {
                console.log("Overview tab shown, calling loadProjectOverview()...");
                loadProjectOverview(false); // Load overview data when tab is shown, don't force refresh
            } else if (targetTabHref === '#graphs') {
                console.log("Graphs tab shown, calling loadProjectGraphs()...");
                loadProjectGraphs(false); // Load graph data when tab is shown, don't force refresh
            } else {
                // Close WebSocket when switching to other tabs
            if (ws && ws.readyState === WebSocket.OPEN) {
                    console.log('Closing WebSocket when switching away from chat tab');
                    ws.close();
                }
            }
        });
    });
    
    // Add additional event listeners to the sidebar navigation
    document.querySelectorAll('.project-sidebar .nav-link[data-bs-toggle="tab"]').forEach(sidebarLink => {
        sidebarLink.addEventListener('click', function(e) {
            // We only need to manage the active class visually for the sidebar itself.
            // Bootstrap handles the actual tab switching via data-bs-toggle.
            
            // Update active class in sidebar
            document.querySelectorAll('.project-sidebar .nav-link').forEach(link => {
                link.classList.remove('active');
            });
            this.classList.add('active');
            
            // NO NEED TO PREVENT DEFAULT OR MANUALLY CALL tab.show() or load functions here.
            // The 'shown.bs.tab' listener above will handle loading data after Bootstrap shows the tab.
        });
    });
    
    // Chat functionality
    const chatMessages = document.getElementById('chat-messages');
    const messageInput = document.getElementById('message-input');
    const sendButton = document.getElementById('send-button');
    
    function setupChatWebSocket() {
        if (ws && ws.readyState === WebSocket.OPEN) {
            console.log('WebSocket already open, skipping setup');
            return;
        }
        
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws/{{ project._id }}`;
            
        console.log('Setting up WebSocket connection to:', wsUrl);
            
        ws = new WebSocket(wsUrl);
        
        ws.onopen = function() {
                console.log('WebSocket connection established');
            
            // Enable UI elements when connected
            if (messageInput && sendButton) {
                messageInput.disabled = false;
                sendButton.disabled = false;
                    }
            };
            
            ws.onmessage = function(event) {
            console.log('Message received:', event.data);
            
                try {
                    const data = JSON.parse(event.data);
                
                // Handle history response
                if (data.action === 'history_response') {
                    displayChatHistory(data.messages);
                        return;
                    }
                    
                // Skip system messages
                if (data.type === 'system') {
                    console.log('System message:', data.message);
                            return;
                        }
                        
                // Handle typing indicator
                if (data.is_typing) {
                    updateTypingIndicator(data);
                        return;
                    }
                    
                // Handle streaming message completion
                if (data.stream_complete) {
                    // Remove typing indicator if exists
                    const typingMessage = document.querySelector('.message-ai.typing');
                    if (typingMessage) {
                        typingMessage.remove();
                    }
                    
                    // Finalize the streaming message
                    const streamingMessage = document.querySelector('.message-ai.streaming');
                    if (streamingMessage) {
                        streamingMessage.classList.remove('streaming');
                    }
                    
                    // Re-enable input fields
                    if (messageInput && sendButton) {
                        messageInput.disabled = false;
                        sendButton.disabled = false;
                        messageInput.focus();
                    }
                    
                    scrollToBottom();
                    return;
                }
                    
                // For streaming chunks, append to existing message or create new one
                    if (data.is_streaming) {
                    appendStreamingMessage(data);
                        return;
                    }
                    
                // Regular message
                displayMessage(data);
                    
                } catch (error) {
                console.error('Error parsing message:', error);
                }
            };
            
            ws.onclose = function(event) {
            console.log('WebSocket connection closed:', event.code, event.reason);
            
            // Disable UI elements when disconnected
            if (messageInput && sendButton) {
                messageInput.disabled = true;
                sendButton.disabled = true;
                }
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
        };
        
        // Setup message sending
        if (messageInput && sendButton) {
            messageInput.onkeypress = function(e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            };
            
            sendButton.onclick = sendMessage;
        }
    }
    
    function sendMessage() {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
            console.error('WebSocket not connected');
            return;
        }
        
        const message = messageInput.value.trim();
        if (!message) return;
        
        // Clear input and disable until response is received
        messageInput.value = '';
        messageInput.disabled = true;
        sendButton.disabled = true;
        
        // Create a temporary message element to show immediately
        const tempMessage = {
            sender: "{{ current_user.username }}",
            message: message,
            timestamp: new Date().toISOString(),
            is_ai: false
        };
        
        // Display user message locally immediately
        displayMessage(tempMessage);
        
        // Send message to server
        ws.send(JSON.stringify({
            message: message
        }));
        
        console.log('Message sent, waiting for response...');
    }
    
    function fetchChatHistory() {
        if (!ws || ws.readyState !== WebSocket.OPEN) {
            console.log('WebSocket not connected, deferring history request');
            setTimeout(fetchChatHistory, 500);
            return;
        }
        
        console.log('Requesting chat history');
        ws.send(JSON.stringify({
            action: 'get_history'
        }));
    }
    
    function displayChatHistory(messages) {
        if (!chatMessages) return;
        
        console.log('Displaying chat history:', messages.length, 'messages');
        
        // Clear existing messages
        chatMessages.innerHTML = '';
        
        // Display each message
        messages.forEach(message => {
            displayMessage(message, true);
        });
        
        // Scroll to bottom
        scrollToBottom();
    }
    
    function displayMessage(message, isHistory = false) {
        if (!chatMessages) return;
        
        const messageElement = document.createElement('div');
        messageElement.classList.add('message');
        
        // Add appropriate class based on sender
        if (message.is_ai) {
            messageElement.classList.add('message-ai');
        } else {
            messageElement.classList.add('message-user');
        }
        
        if (message.is_error) {
            messageElement.classList.add('message-error');
        }
        
        // Create message content
        const messageContent = document.createElement('div');
        messageContent.classList.add('message-content');
        
        // Add user/AI icon
        const iconElement = document.createElement('div');
        if (message.is_ai) {
            iconElement.classList.add('ai-icon');
            iconElement.innerHTML = '<i class="fas fa-robot"></i>';
        } else {
            iconElement.classList.add('user-icon');
            iconElement.innerHTML = message.sender ? message.sender.charAt(0).toUpperCase() : 'U';
        }
        
        // Create message text element
        const messageText = document.createElement('div');
        messageText.classList.add('message-text');
        
        // Format links and code in message
        messageText.innerHTML = formatMessageContent(message.message);
        
        // Assemble message
        messageContent.appendChild(iconElement);
        messageContent.appendChild(messageText);
        messageElement.appendChild(messageContent);
        
        // Add to chat container
        chatMessages.appendChild(messageElement);
        
        // Scroll to bottom if not viewing history
        if (!isHistory) {
            scrollToBottom();
        }
    }
    
    function updateTypingIndicator(data) {
        // Find or create the typing indicator
        let typingIndicator = document.querySelector('.message-ai.typing');
        
        if (!typingIndicator) {
            typingIndicator = document.createElement('div');
            typingIndicator.classList.add('message', 'message-ai', 'typing');
            
            const messageContent = document.createElement('div');
            messageContent.classList.add('message-content');
            
            const iconElement = document.createElement('div');
            iconElement.classList.add('ai-icon');
            iconElement.innerHTML = '<i class="fas fa-robot"></i>';
            
            const messageText = document.createElement('div');
            messageText.classList.add('message-text');
            
            const typingDots = document.createElement('div');
            typingDots.classList.add('message-typing');
            typingDots.innerHTML = '<span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span>';
            
            messageText.appendChild(typingDots);
            messageContent.appendChild(iconElement);
            messageContent.appendChild(messageText);
            typingIndicator.appendChild(messageContent);
            
            chatMessages.appendChild(typingIndicator);
            scrollToBottom();
        }
    }
    
    function appendStreamingMessage(data) {
        // Find existing streaming message or create new one
        let streamingMessage = document.querySelector('.message-ai.streaming');
        
        if (!streamingMessage) {
            // No existing streaming message, create new one
            streamingMessage = document.createElement('div');
            streamingMessage.classList.add('message', 'message-ai', 'streaming');
            
            const messageContent = document.createElement('div');
            messageContent.classList.add('message-content');
            
            const iconElement = document.createElement('div');
            iconElement.classList.add('ai-icon');
            iconElement.innerHTML = '<i class="fas fa-robot"></i>';
            
            const messageText = document.createElement('div');
            messageText.classList.add('message-text');
            messageText.id = 'streaming-message-text';
            
            messageContent.appendChild(iconElement);
            messageContent.appendChild(messageText);
            streamingMessage.appendChild(messageContent);
            
            // Remove typing indicator if exists
            const typingIndicator = document.querySelector('.message-ai.typing');
            if (typingIndicator) {
                typingIndicator.remove();
            }
            
            chatMessages.appendChild(streamingMessage);
            
            // Initialize the message with the first chunk
            const messageTextEl = streamingMessage.querySelector('.message-text');
            if (messageTextEl) {
                messageTextEl.innerHTML = formatMessageContent(data.message);
            }
        } else {
            // Add the new chunk of text to existing message
            const messageText = streamingMessage.querySelector('.message-text');
            if (messageText) {
                // Instead of just appending, append the formatted content
                const formattedChunk = formatMessageContent(data.message);
                messageText.innerHTML += formattedChunk;
            }
        }
        
        scrollToBottom();
    }
    
    function scrollToBottom() {
        if (chatMessages) {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
    }
    
    function formatMessageContent(content) {
        if (!content) return '';
        
        // Convert URLs to links
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        let formattedContent = content.replace(urlRegex, url => {
            return `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`;
        });
        
        // Convert markdown-style code blocks to HTML
        const codeBlockRegex = /```([^`]+)```/g;
        formattedContent = formattedContent.replace(codeBlockRegex, (match, code) => {
            return `<pre><code>${code}</code></pre>`;
        });
        
        // Convert inline code to HTML
        const inlineCodeRegex = /`([^`]+)`/g;
        formattedContent = formattedContent.replace(inlineCodeRegex, (match, code) => {
            return `<code>${code}</code>`;
        });
        
        return formattedContent;
    }
    
    // Load project overview data from API or cache
    function loadProjectOverview(forceRefresh = false) {
        console.log(`--- loadProjectOverview started (forceRefresh: ${forceRefresh}) ---`);
        
        // Find all the specific elements
        const descriptionEl = document.getElementById('overview-description');
        const contractorEl = document.getElementById('overview-contractor');
        const budgetEl = document.getElementById('overview-budget');
        const completionDateEl = document.getElementById('overview-completion-date');
        const statusEl = document.getElementById('overview-status');
        const plansListEl = document.getElementById('overview-plans-list');
        const meetingsListEl = document.getElementById('overview-meetings-list');
        const lastUpdatedEl = document.getElementById('overview-last-updated');
        const errorContainer = document.getElementById('overview-content-area');

        console.log(`Element check: descriptionEl=${!!descriptionEl}, contractorEl=${!!contractorEl}, budgetEl=${!!budgetEl}, completionDateEl=${!!completionDateEl}, statusEl=${!!statusEl}, plansListEl=${!!plansListEl}, meetingsListEl=${!!meetingsListEl}, lastUpdatedEl=${!!lastUpdatedEl}, errorContainer=${!!errorContainer}`);

        if (!errorContainer) {
            console.error("loadProjectOverview ERROR: errorContainer element not found. Aborting.");
            return; // Need at least the main container
        }

        // Helper function to display data or placeholder
        const displayData = (element, value) => {
            console.log(`displayData called for element: ${element ? element.id : 'null'}, value: ${value}`);
            if (element) {
                element.textContent = (value && value.trim() !== '' && value.toLowerCase() !== 'לא ידוע') ? value : 'לא ידוע';
            } else {
                console.warn(`displayData warning: element not found.`);
            }
        };

        // Helper function to populate list group
        const populateList = (listElement, items) => {
            console.log(`populateList called for element: ${listElement ? listElement.id : 'null'}, items:`, items);
            if (listElement) {
                listElement.innerHTML = ''; // Clear previous items
                if (items && items.length > 0 && !(items.length === 1 && items[0].toLowerCase() === 'לא ידוע')) {
                    items.forEach(item => {
                    const li = document.createElement('li');
                        li.classList.add('list-group-item');
                        li.textContent = item;
                        listElement.appendChild(li);
                    });
                    console.log(`populateList: Populated ${items.length} items.`);
            } else {
                const li = document.createElement('li');
                    li.classList.add('list-group-item', 'text-muted');
                    li.textContent = 'אין מידע זמין';
                    listElement.appendChild(li);
                    console.log(`populateList: No valid items found, showing 'אין מידע זמין'.`);
                }
            } else {
                console.warn(`populateList warning: listElement not found.`);
            }
        };

        // Helper to update the timestamp display
        const updateTimestamp = (timestamp) => {
            console.log(`updateTimestamp called with timestamp: ${timestamp}`);
            if (lastUpdatedEl) {
                const date = new Date(timestamp);
                const options = { year: 'numeric', month: 'numeric', day: 'numeric', hour: '2-digit', minute: '2-digit' };
                lastUpdatedEl.textContent = `עודכן לאחרונה: ${date.toLocaleDateString('he-IL', options)}`;
                console.log(`updateTimestamp: Updated element ${lastUpdatedEl.id}`);
            } else {
                console.warn(`updateTimestamp warning: lastUpdatedEl not found.`);
            }
        };

        // Clear previous error messages immediately
        const existingError = errorContainer.querySelector('.alert');
        if (existingError) {
            console.log("Clearing existing error message.");
            existingError.remove();
        }

        // Try to load from cache first unless forcing refresh
        if (!forceRefresh) {
            console.log("Attempting to load overview from cache...");
            try {
                const itemStr = localStorage.getItem(OVERVIEW_CACHE_KEY);
                if (itemStr) {
                    try {
                        const item = JSON.parse(itemStr);
                        const now = new Date().getTime();

                        if (now <= item.timestamp + CACHE_DURATION_MS) {
                            console.log('Successfully retrieved overview from cache. Populating UI...');
                            const data = item.data;
                            
                            // Populate elements from cached data
                            displayData(descriptionEl, data.description || '{{ project.description }}');
                            displayData(contractorEl, data.contractor);
                            displayData(budgetEl, data.budget);
                            displayData(completionDateEl, data.completion_date);
                            displayData(statusEl, data.status);
                            populateList(plansListEl, data.plans);
                            populateList(meetingsListEl, data.meetings);
                            updateTimestamp(item.timestamp); // Use cache timestamp
                            
                            // Hide loading indicator
                            toggleLoading('overview-loading', false);
                            
                            console.log("--- loadProjectOverview finished (loaded from cache) ---");
                            return; // Don't fetch if cache is valid
                        } else {
                            localStorage.removeItem(OVERVIEW_CACHE_KEY); // Remove expired cache
                            console.log(`Cache expired for key: ${OVERVIEW_CACHE_KEY}`);
                        }
                    } catch (e) {
                        console.error("Error parsing cached item:", e);
                        localStorage.removeItem(OVERVIEW_CACHE_KEY); // Clear potentially corrupted cache item
                    }
                } else {
                    console.log("No cached data found");
                }
            } catch (e) {
                console.error("Error reading from localStorage:", e);
                localStorage.removeItem(OVERVIEW_CACHE_KEY); // Clear potentially corrupted cache item
            }
        } else {
            console.log("Force refresh requested, skipping cache check.");
        }

        // --- Fetching required ---
        console.log("Fetching required. Showing loading indicator and resetting fields...");
        
        // Show loading indicator *before* resetting fields
        toggleLoading('overview-loading', true);

        // Reset fields to loading state *after* showing spinner
        displayData(descriptionEl, 'טוען...');
        displayData(contractorEl, 'טוען...');
        displayData(budgetEl, 'טוען...');
        displayData(completionDateEl, 'טוען...');
        displayData(statusEl, 'טוען...');
        if(plansListEl) plansListEl.innerHTML = '<li class="list-group-item">טוען...</li>';
        if(meetingsListEl) meetingsListEl.innerHTML = '<li class="list-group-item">טוען...</li>';
        if (lastUpdatedEl) lastUpdatedEl.textContent = 'עודכן לאחרונה: טוען...';

        console.log('Starting fetch request to /api/projects/{{ project._id }}/overview...');
        fetch(`/api/projects/{{ project._id }}/overview`)
            .then(response => {
                console.log(`Fetch response received. Status: ${response.status}`);
                if (!response.ok) {
                    // Handle HTTP errors like 404, 500
                    console.error(`Fetch failed with HTTP status: ${response.status}`);
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                console.log("Fetch response OK. Parsing JSON...");
                return response.json();
            })
            .then(data => {
                console.log("Fetch JSON parsed successfully:", data);
                // Clear errors from previous attempts inside the fetch chain if any
                const currentError = errorContainer.querySelector('.alert');
                if (currentError) {
                    console.log("Clearing previous error alert before processing data.");
                    currentError.remove();
                }

                if (data.error) {
                    console.error('API returned an error in the data payload:', data.error);
                    if (errorContainer) {
                        console.log("Displaying API error message.");
                        errorContainer.insertAdjacentHTML('afterbegin', `<div class="alert alert-warning">שגיאה בקבלת נתונים: ${data.error}</div>`);
                    }
                    // Still display project description as fallback
                    displayData(descriptionEl, '{{ project.description }}');
                    // Set other fields to unknown explicitly on error
                    displayData(contractorEl, 'לא ידוע');
                    displayData(budgetEl, 'לא ידוע');
                    displayData(completionDateEl, 'לא ידוע');
                    displayData(statusEl, 'לא ידוע');
                    populateList(plansListEl, []);
                    populateList(meetingsListEl, []);
                    if (lastUpdatedEl) lastUpdatedEl.textContent = 'עדכון נכשל';
                    return;
                }

                console.log("API data is valid. Populating UI elements...");
                // Populate elements from fetched data
                displayData(descriptionEl, data.description || '{{ project.description }}');
                displayData(contractorEl, data.contractor);
                displayData(budgetEl, data.budget);
                displayData(completionDateEl, data.completion_date);
                displayData(statusEl, data.status);
                populateList(plansListEl, data.plans);
                populateList(meetingsListEl, data.meetings);

                console.log("Setting fetched data into cache...");
                // Store fetched data in cache
                setCachedItem(OVERVIEW_CACHE_KEY, data);
                updateTimestamp(new Date().getTime()); // Use current time for freshly fetched data
            })
            .catch(error => {
                console.error('Fetch API call failed:', error);
                // Clear previous errors first
                const currentError = errorContainer.querySelector('.alert');
                if (currentError) currentError.remove();
                if (errorContainer) {
                    console.log("Displaying fetch error message.");
                    errorContainer.insertAdjacentHTML('afterbegin', '<div class="alert alert-danger">שגיאה בטעינת סקירת הפרויקט</div>');
                }
                // Fallback on network or other errors
                displayData(descriptionEl, '{{ project.description }}');
                displayData(contractorEl, 'לא ידוע');
                displayData(budgetEl, 'לא ידוע');
                displayData(completionDateEl, 'לא ידוע');
                displayData(statusEl, 'לא ידוע');
                populateList(plansListEl, []);
                populateList(meetingsListEl, []);
                if (lastUpdatedEl) lastUpdatedEl.textContent = 'עדכון נכשל';
            })
            .finally(() => {
                console.log("Fetch process complete (finally block). Hiding loading indicator.");
                // Hide loading indicator regardless of success or failure
                toggleLoading('overview-loading', false);
                console.log("--- loadProjectOverview finished (fetch attempt) ---");
            });
    }
    
    // Load project graphs data from API or cache
    function loadProjectGraphs(forceRefresh = false) {
        console.log(`loadProjectGraphs called (forceRefresh: ${forceRefresh})`);
            const graphsLoading = document.getElementById('graphs-loading');
        const container = document.getElementById('visualizations-container');
        
        if (!container) return;
        
        // Destroy existing chart instances before loading new ones or from cache
        destroyCharts();
        
        // Clear container
        container.innerHTML = '';
        
        // Try to load from cache first unless forcing refresh
        if (!forceRefresh) {
            console.log("Attempting to load graphs from cache...");
            try {
                const itemStr = localStorage.getItem(GRAPHS_CACHE_KEY);
                if (itemStr) {
                    try {
                        const item = JSON.parse(itemStr);
                        const now = new Date().getTime();
                        
                        if (now <= item.timestamp + CACHE_DURATION_MS) {
                            console.log('Successfully retrieved graphs from cache. Rendering...');
                            renderVisualizations(item.data);
                            console.log("--- loadProjectGraphs finished (loaded from cache) ---");
                            return; // Don't fetch if cache is valid
                    } else {
                            localStorage.removeItem(GRAPHS_CACHE_KEY); // Remove expired cache
                            console.log(`Cache expired for key: ${GRAPHS_CACHE_KEY}`);
                        }
                    } catch (e) {
                        console.error("Error parsing cached graphs data:", e);
                        localStorage.removeItem(GRAPHS_CACHE_KEY); // Clear potentially corrupted cache item
                    }
                } else {
                    console.log("No cached graphs data found");
                }
            } catch (e) {
                console.error("Error reading graphs data from localStorage:", e);
                localStorage.removeItem(GRAPHS_CACHE_KEY); // Clear potentially corrupted cache item
            }
        } else {
            console.log("Force refresh requested, skipping cache check.");
        }
        
        // --- Fetching required ---
        console.log("Fetching required for graphs. Showing loading indicator...");
        
        // Show loading indicator
        if (graphsLoading) {
            toggleLoading('graphs-loading', true);
        }
        
        console.log('Starting fetch request to /api/projects/{{ project._id }}/graphs...');
        fetch(`/api/projects/{{ project._id }}/graphs`)
            .then(response => {
                console.log(`Fetch response received. Status: ${response.status}`);
                if (!response.ok) {
                    console.error(`Fetch failed with HTTP status: ${response.status}`);
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                console.log("Fetch response OK. Parsing JSON...");
                return response.json();
            })
            .then(data => {
                console.log("Received data from /api/projects/.../graphs:", data);
                if (data.error) {
                    console.error('Error in graph data:', data.error);
                    container.innerHTML = `<div class="alert alert-warning">${data.error}</div>`;
                    return;
                }
                
                // Initialize charts with the data
                renderVisualizations(data);
                
                // Store fetched data in cache
                console.log("Setting fetched graphs data into cache...");
                setCachedItem(GRAPHS_CACHE_KEY, data);
            })
            .catch(error => {
                console.error('Error fetching project graphs:', error);
                container.innerHTML = '<div class="alert alert-danger">שגיאה בטעינת מידע גרפי</div>';
            })
            .finally(() => {
                console.log("Graphs fetch process complete. Hiding loading indicator.");
                if (graphsLoading) {
                    toggleLoading('graphs-loading', false);
                }
                console.log("--- loadProjectGraphs finished (fetch attempt) ---");
            });
    }
    
    // Render visualizations dynamically based on AI suggestions
    function renderVisualizations(data) {
        console.log("renderVisualizations called with data:", data);
        const container = document.getElementById('visualizations-container');
        if (!container) {
            console.error("Visualization container not found!");
            return;
        }
        
        // Clear previous visualizations and destroy old charts
        destroyCharts();
        container.innerHTML = '';

        if (!data || !data.visualizations || data.visualizations.length === 0) {
            container.innerHTML = '<div class="alert alert-info text-center">לא נמצאו תצוגות נתונים רלוונטיות כרגע.</div>';
            console.log('No visualizations data received or data is empty.');
            return;
        }

        console.log(`Rendering ${data.visualizations.length} visualizations...`);

        data.visualizations.forEach((viz, index) => {
            const vizId = `visualization-${index}`;

            // Create card structure
            const card = document.createElement('div');
            card.className = 'card visualization-card mb-4'; // Added mb-4 for spacing

            let cardContent = `<div class="visualization-header">`;
            if (viz.title) {
                cardContent += `<h5 class="visualization-title">${viz.title}</h5>`;
            }
            if (viz.description) {
                cardContent += `<p class="visualization-description">${viz.description}</p>`;
            }
            cardContent += `</div><div class="visualization-content">`; // End header, start content

            // Check visualization type
            if (viz.type === 'pie' || viz.type === 'doughnut' || viz.type === 'bar' || viz.type === 'line') {
                // Chart type
                if (viz.data && viz.data.labels && viz.data.datasets) {
                    const chartContainer = document.createElement('div');
                    chartContainer.className = 'chart-container'; // Added class for CSS styling
                    const canvas = document.createElement('canvas');
                    canvas.id = vizId;
                    chartContainer.appendChild(canvas);
                    cardContent += chartContainer.outerHTML;

                    // Prepare chart data - Use professional palette
                    const chartData = {
                        labels: viz.data.labels,
                        datasets: viz.data.datasets.map((dataset, i) => ({
                            ...dataset,
                            backgroundColor: dataset.backgroundColor || professionalPalette.map(color => `${color}B3`), // Add alpha transparency (e.g., B3 = 70%)
                            borderColor: dataset.borderColor || professionalPalette,
                            borderWidth: dataset.borderWidth || (viz.type === 'line' ? 2 : 1),
                            pointBackgroundColor: dataset.pointBackgroundColor || professionalPalette,
                            pointBorderColor: dataset.pointBorderColor || '#fff',
                            pointHoverBackgroundColor: dataset.pointHoverBackgroundColor || '#fff',
                            pointHoverBorderColor: dataset.pointHoverBorderColor || professionalPalette[i % professionalPalette.length],
                            fill: dataset.fill !== undefined ? dataset.fill : (viz.type === 'line'), // Fill area under line charts
                        }))
                    };

                     // Merge default options with specific options for chart type
                    const specificOptions = {};
                    if (viz.type === 'pie' || viz.type === 'doughnut') {
                        specificOptions.plugins = {
                             legend: { display: true, position: 'bottom' }, // Example: legend at bottom for pies
                             tooltip: chartOptions.plugins.tooltip // Keep default tooltips
                        };
                        // Remove axes for pie/doughnut
                        specificOptions.scales = {};
                    } else {
                        // Keep default scales for bar/line
                        specificOptions.scales = chartOptions.scales;
                    }

                    // Deep merge options - specificOptions will override chartOptions where keys clash
                    const finalOptions = deepMerge(chartOptions, specificOptions);


                    // Delay chart initialization slightly to ensure DOM is ready
                    setTimeout(() => {
                        const ctx = document.getElementById(vizId);
                        if (ctx) {
                            try {
                                activeCharts[vizId] = new Chart(ctx, {
                                    type: viz.type,
                                    data: chartData,
                                    options: finalOptions // Use the merged options
                                });
                                console.log(`Rendered chart: ${viz.title || vizId}`);
                } catch (e) {
                                console.error(`Error rendering chart ${vizId}:`, e);
                                card.innerHTML = `<div class="card-body"><p class="text-danger">שגיאה ביצירת התרשים.</p></div>`; // Show error inside card
                            }
                    } else {
                             console.error(`Canvas element not found after delay for ID: ${vizId}`);
                             card.innerHTML = `<div class="card-body"><p class="text-danger">שגיאה באתחול התרשים (לא נמצא אלמנט).</p></div>`;
                        }
                    }, 50); // 50ms delay

                    } else {
                    console.error(`Invalid data structure for chart ${vizId}:`, viz.data);
                    cardContent += '<p class="text-danger">מבנה נתונים שגוי עבור התרשים.</p>';
                }

            } else if (viz.type === 'table') {
                // Table type
                if (viz.data && viz.data.headers && viz.data.rows) {
                    let tableHtml = '<div class="table-responsive"><table class="table table-striped table-hover table-sm table-bordered">'; // Added table-bordered
                    tableHtml += '<thead class="thead-light">'; // Use thead-light for header background
                    tableHtml += '<tr>';
                    viz.data.headers.forEach(header => {
                        tableHtml += `<th>${header}</th>`;
                    });
                    tableHtml += '</tr></thead><tbody>';
                    viz.data.rows.forEach(row => {
                        tableHtml += '<tr>';
                        row.forEach(cell => {
                            // Basic sanitization/escaping might be needed here depending on data source
                            tableHtml += `<td>${cell}</td>`;
                        });
                        tableHtml += '</tr>';
                    });
                    tableHtml += '</tbody></table></div>'; // Close responsive div
                    cardContent += tableHtml;

                        } else {
                    console.error(`Invalid data structure for table ${vizId}:`, viz.data);
                    cardContent += '<p class="text-danger">מבנה נתונים שגוי עבור הטבלה.</p>';
                }
                } else {
                // Unknown visualization type
                console.warn(`Unknown visualization type: ${viz.type}`);
                 cardContent += '<p class="text-warning">סוג תצוגה לא נתמך.</p>';
            }

            cardContent += '</div>'; // End visualization-content
            card.innerHTML = cardContent;
            container.appendChild(card);
        });
    }
    
    // Helper function for deep merging options objects
    // Simple deep merge, only handles plain objects and arrays
    function deepMerge(target, source) {
        let output = Object.assign({}, target);
        if (isObject(target) && isObject(source)) {
            Object.keys(source).forEach(key => {
                if (isObject(source[key])) {
                    if (!(key in target))
                        Object.assign(output, { [key]: source[key] });
                    else
                        output[key] = deepMerge(target[key], source[key]);
            } else {
                    Object.assign(output, { [key]: source[key] });
                }
            });
        }
        return output;
    }

    function isObject(item) {
        return (item && typeof item === 'object' && !Array.isArray(item));
    }

    // Function to destroy all active chart instances
    function destroyCharts() {
        console.log("Destroying existing charts...");
        Object.keys(activeCharts).forEach(chartId => {
            if (activeCharts[chartId]) {
                try {
                    activeCharts[chartId].destroy();
                    console.log(`Destroyed chart: ${chartId}`);
                } catch (e) {
                    console.error(`Error destroying chart ${chartId}:`, e);
                }
                delete activeCharts[chartId];
            }
        });
         activeCharts = {}; // Reset the map
    }
    
    // Format JSON content for display
    function formatJsonContent(jsonObj) {
        let result = '';
        
        // Helper function to create a properly formatted section
        function formatSection(obj, prefix = '') {
            let sectionHtml = '';
            
            // Handle top-level project details
            if (prefix === '' && obj.project_details) {
                return formatSection(obj.project_details, '');
            }
            
            // Handle arrays
            if (Array.isArray(obj)) {
                sectionHtml += '<ul>';
                for (const item of obj) {
                    if (typeof item === 'object' && item !== null) {
                        sectionHtml += '<li>' + formatSection(item, prefix) + '</li>';
                    } else {
                        sectionHtml += '<li>' + formatLineContent(String(item)) + '</li>';
                    }
                }
                sectionHtml += '</ul>';
                return sectionHtml;
            }
            
            // Handle objects - create sections for each key
            if (typeof obj === 'object' && obj !== null) {
                let contentHtml = '';
                
                // Process keys in a specific order if they exist
                const orderedKeys = ['summary', 'description', 'status', 'progress', 'risks', 'next_steps', 'recommendations'];
                const remainingKeys = Object.keys(obj).filter(key => !orderedKeys.includes(key));
                const processKeys = [...orderedKeys.filter(key => key in obj), ...remainingKeys];
                
                for (const key of processKeys) {
                    const value = obj[key];
                    
                    if (value === null || value === undefined) {
                        continue;
                    }
                    
                    const fullKey = prefix ? `${prefix}.${key}` : key;
                    
                    if (typeof value === 'object' && !Array.isArray(value) && value !== null) {
                        // For nested objects, create a subsection
                        contentHtml += `<div class="content-subsection">`;
                        contentHtml += `<h5>${formatTitle(key)}</h5>`;
                        contentHtml += formatSection(value, fullKey);
                        contentHtml += `</div>`;
                    } else if (Array.isArray(value)) {
                        // For arrays, create a list
                        contentHtml += `<div class="content-subsection">`;
                        contentHtml += `<h5>${formatTitle(key)}</h5>`;
                        contentHtml += formatSection(value, fullKey);
                        contentHtml += `</div>`;
                    } else {
                        // For simple values like strings or numbers
                        contentHtml += `<p><strong>${formatTitle(key)}:</strong> ${formatLineContent(String(value))}</p>`;
                    }
                }
                
                return contentHtml;
            }
            
            // Handle primitive values
            return formatLineContent(String(obj));
        }
        
        // Helper to format keys as titles
        function formatTitle(key) {
            // Replace underscores with spaces and capitalize each word
            return key
                .replace(/_/g, ' ')
                .replace(/\b\w/g, char => char.toUpperCase());
        }
        
        // Helper to format text content with links and formatting
        function formatLineContent(text) {
            if (!text) return '';
            
            // Convert URLs to links
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            let formattedText = text.replace(urlRegex, url => {
                return `<a href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`;
            });
            
            return formattedText;
        }
        
        result = formatSection(jsonObj);
        return result;
    }
    
    // Check if we're starting on a tab that needs data loading
    const activeTab = document.querySelector('.tab-pane.active');
    if (activeTab) {
        console.log(`Initial active tab detected: #${activeTab.id}. Loading data...`);
        if (activeTab.id === 'overview') {
            loadProjectOverview(false); // Don't force refresh on initial load
        } else if (activeTab.id === 'graphs') {
            loadProjectGraphs(false); // Don't force refresh on initial load
        } else if (activeTab.id === 'chat') {
            setupChatWebSocket();
            fetchChatHistory();
        }
    } else {
        console.log("No active tab found on initial load. Waiting for tab change event.");
    }
    
    // Setup event handlers after all functions are defined
    
    // Update refresh button handlers
    const refreshOverviewButton = document.getElementById('refresh-overview');
    if (refreshOverviewButton) {
        refreshOverviewButton.addEventListener('click', function() {
            console.log("Refresh Overview button clicked.");
            // Clear cache before forcing refresh
            localStorage.removeItem(OVERVIEW_CACHE_KEY);
            loadProjectOverview(true); // Pass true to force refresh
        });
    }

    const refreshGraphsButton = document.getElementById('refresh-graphs');
    if (refreshGraphsButton) {
        refreshGraphsButton.addEventListener('click', function() {
            console.log("Refresh Graphs button clicked.");
            // Clear cache before forcing refresh
            localStorage.removeItem(GRAPHS_CACHE_KEY);
            loadProjectGraphs(true); // Pass true to force refresh
        });
    }

    // Add a helper function to reliably manage the loading indicator:

    // Helper function to show/hide loading indicator
    function toggleLoading(id, show) {
        const element = document.getElementById(id);
        if (element) {
            if (show) {
                element.classList.add('d-flex');
                element.style.display = 'flex';
                } else {
                element.classList.remove('d-flex');
                element.style.display = 'none';
            }
        }
    }

    // Use this function whenever loading needs to be shown/hidden:
    // toggleLoading('overview-loading', true);  // To show
    // toggleLoading('overview-loading', false); // To hide

    // Helper function to set cached item
    function setCachedItem(key, data) {
        console.log(`Setting cache for key: ${key}`);
        try {
            const item = {
                data: data,
                timestamp: new Date().getTime()
            };
            localStorage.setItem(key, JSON.stringify(item));
            console.log(`Data cached successfully for key: ${key}`);
        } catch (e) {
            console.error(`Error writing to localStorage for key ${key}:`, e);
            // Handle potential storage quota exceeded error
            if (e.name === 'QuotaExceededError') {
                console.warn("LocalStorage quota exceeded. Clearing old caches.");
                // Clear all project cache items
                Object.keys(localStorage).forEach(storageKey => {
                    if (storageKey.startsWith('project_')) {
                        localStorage.removeItem(storageKey);
                    }
                });
                // Try again
                try {
                    localStorage.setItem(key, JSON.stringify({
                        data: data,
                        timestamp: new Date().getTime()
                    }));
                } catch (retryError) {
                    console.error("Still failed to store after clearing cache:", retryError);
                }
            }
        }
    }

    // Initialize the correct tab based on URL hash or default to overview
    function initializeTabFromUrlHash() {
        let targetTabId = 'overview'; // Default tab
        
        // Check if URL has a hash and it corresponds to a valid tab
        if (window.location.hash) {
            const hash = window.location.hash.substring(1); // Remove the # character
            const validTabs = ['overview', 'chat', 'tasks', 'files', 'graphs'];
            
            if (validTabs.includes(hash)) {
                targetTabId = hash;
            }
        }
        
        console.log(`Initializing tab from URL hash: #${targetTabId}`);
        
        // Find and click the tab link for the target tab
        const tabLink = document.querySelector(`.project-sidebar .nav-link[href="#${targetTabId}"]`);
        if (tabLink) {
            tabLink.click();
        } else {
            console.warn(`Tab link for #${targetTabId} not found`);
            // Fallback to first tab if target tab can't be found
            const firstTabLink = document.querySelector('.project-sidebar .nav-link');
            if (firstTabLink) {
                firstTabLink.click();
            }
        }
    }
    
    // Initialize the correct tab after DOM is loaded
    initializeTabFromUrlHash();
});
</script>
{% endblock %} 
